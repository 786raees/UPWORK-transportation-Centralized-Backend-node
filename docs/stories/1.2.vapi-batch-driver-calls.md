# Story 1.2: VAPI Batch Driver Calls

## Status
Draft

## Story
**As a** system administrator,  
**I want** to make VAPI AI-powered calls to multiple drivers simultaneously using a list of driver IDs,  
**so that** I can efficiently conduct batch safety communications or emergency notifications to multiple drivers at once.

## Acceptance Criteria
1. Create new API endpoint `POST /api/vapi-calls/batch` that accepts an array of driver IDs
2. Process multiple drivers sequentially with rate limiting (2-second delays between calls)
3. Make VAPI API calls for each valid driver with their complete information
4. Return a comprehensive JSON response with success/failure status for each driver
5. Handle partial failures gracefully (some drivers succeed, others fail)
6. Follow existing batch processing patterns from the current RingCentral implementation
7. Implement proper error aggregation and reporting for batch operations

## Tasks / Subtasks
- [ ] Add batch VAPI call controller method (AC: 1, 2, 3, 4, 5)
  - [ ] Add `makeVapiCallsToMultipleDrivers` method to `controllers/callController.js`
  - [ ] Implement driver ID validation and bulk lookup using existing Sequelize patterns
  - [ ] Process drivers sequentially with 2-second rate limiting
  - [ ] Use existing VAPI client from Story 1.1 for individual calls
  - [ ] Aggregate results with success/failure tracking
- [ ] Create new batch API route (AC: 1)
  - [ ] Add route `POST /api/vapi-calls/batch` to `routes/calls.js`
  - [ ] Connect route to new batch controller method
- [ ] Implement batch error handling (AC: 5, 7)
  - [ ] Handle individual driver failures without stopping batch
  - [ ] Collect and report errors for each failed driver
  - [ ] Return comprehensive batch results with partial success handling
- [ ] Rate limiting implementation (AC: 2)
  - [ ] Add 2-second delays between VAPI calls to prevent API rate limiting
  - [ ] Follow existing batch processing pattern from RingCentral implementation
- [ ] Testing (AC: 1-7)
  - [ ] Test with multiple valid driver IDs
  - [ ] Test with mixed valid/invalid driver IDs
  - [ ] Test rate limiting functionality
  - [ ] Test error handling with partial failures

## Dev Notes

### Dependencies
**CRITICAL: Requires Story 1.1 to be completed and tested** - This story builds on the working VAPI campaign client utility and single driver call functionality from Story 1.1.

**Prerequisites:**
- Story 1.1 VAPI client (`utils/vapiClient.js`) must be fully implemented and tested
- All VAPI environment variables (API_KEY, ASSISTANT_ID, PHONENUMBER_ID) must be configured
- Database connection must be working (required for bulk driver lookups)
- Test driver `DRV_1753320481164` should be available for testing

### Technology Stack Context
[Source: docs/architecture.md#technology-stack]
- **Framework**: Express.js 5.1.0 - maintain existing patterns
- **Database**: MySQL via Sequelize 6.37.7 - use existing Driver model for bulk lookups
- **HTTP Client**: Axios 1.10.0 - use existing VAPI client from Story 1.1
- **Rate Limiting**: Use JavaScript setTimeout for delays between calls

### Existing Batch Processing Pattern
[Source: existing callController.js analysis + Story 1.1 VAPI implementation]
Follow the existing `makeCallsToMultipleDrivers` pattern, adapted for VAPI:
```javascript
// VAPI batch pattern (adapted from RingCentral pattern)
const results = [];
for (const driver of validDrivers) {
  try {
    // Use Story 1.1 VAPI client (creates campaign per driver)
    const vapiResponse = await createVapiCall(driver);
    results.push({
      driverId: driver.driverId,
      success: true,
      campaignId: vapiResponse.campaignId,
      callId: vapiResponse.callId,
      phoneNumber: driver.phoneNumber,
      driverName: `${driver.firstName} ${driver.lastName}`,
      status: vapiResponse.status // "scheduled"
    });
  } catch (error) {
    results.push({
      driverId: driver.driverId,
      success: false,
      error: error.message,
      status: 'vapi_api_error'
    });
  }
  // Critical: Rate limiting delay for VAPI API
  await new Promise(resolve => setTimeout(resolve, 2000));
}
```

### Driver Model Context
[Source: docs/architecture.md#data-models and Story 1.1]
Use existing Driver model for bulk lookups:
```javascript
// Bulk driver lookup pattern
const drivers = await Driver.findAll({
  where: {
    driverId: {
      [Op.in]: driverIds
    }
  }
});
```

### VAPI Client Integration
[Source: Story 1.1 working implementation]
Reuse the VAPI campaign client utility created in Story 1.1:
```javascript
// Import from Story 1.1
const { createVapiCall } = require('../utils/vapiClient');

// Use for each driver in batch (creates individual campaigns)
const vapiResponse = await createVapiCall(driver);

// Response includes campaignId and status "scheduled"
// { success: true, campaignId: "...", callId: "...", status: "scheduled" }
```

**CRITICAL**: Story 1.1 uses VAPI campaign endpoint (`/campaign`) with `customers` array format, not `/call` endpoint.

### Request/Response Format
**Request Format:**
```javascript
{
  "driverIds": ["DRV_1753320481164", "DRV_1753320481165", "DRV_1753320481166"],
  "metadata": {
    "callType": "batch_safety_check",
    "source": "vapi_integration"
  }
}
```

**Response Format (based on Story 1.1 actual implementation):**
```javascript
{
  "success": true,
  "totalDrivers": 3,
  "successfulCalls": 2,
  "failedCalls": 1,
  "results": [
    {
      "driverId": "DRV_1753320481164",
      "success": true,
      "campaignId": "50a3619d-5598-4032-ac1c-41d220049086",
      "callId": "50a3619d-5598-4032-ac1c-41d220049086",
      "phoneNumber": "+1 (219) 200-2824",
      "driverName": "Alina Khan",
      "status": "scheduled"
    },
    {
      "driverId": "DRV_1753320481165", 
      "success": true,
      "campaignId": "60b4729e-6699-5143-bd2d-52e331049087",
      "callId": "60b4729e-6699-5143-bd2d-52e331049087",
      "phoneNumber": "+1 (317) 559-2104",
      "driverName": "Andy Smith",
      "status": "scheduled"
    },
    {
      "driverId": "DRV_1753320481166",
      "success": false,
      "error": "Driver not found",
      "status": "driver_not_found"
    }
  ]
}
```

### File Locations
[Source: docs/architecture.md#project-structure and Story 1.1]
- **Controller**: `controllers/callController.js` - add new batch method
- **Routes**: `routes/calls.js` - add new batch endpoint
- **Utilities**: Use existing `utils/vapiClient.js` from Story 1.1
- **Environment**: Use existing VAPI credentials from Story 1.1

### Environment Variables Required
[Source: Story 1.1 working implementation]
```env
VAPI_API_KEY=your_vapi_api_key_here
VAPI_ASSISTANT_ID=your_assistant_id_here
VAPI_PHONENUMBER_ID=your_phone_number_id_here
```

**CRITICAL**: All three environment variables are required for VAPI campaign API to work.

### Error Handling Strategy
Handle three types of errors:
1. **Driver Not Found**: Individual driver lookup fails
2. **VAPI API Error**: Individual VAPI call fails
3. **System Error**: Database connection or other system issues

Each error should be captured in the results array without stopping the batch process.

### Rate Limiting Requirements
[Source: existing RingCentral batch implementation]
- **Delay**: 2 seconds between individual VAPI calls
- **Method**: Use `setTimeout` with Promise wrapper
- **Pattern**: Follow existing RingCentral batch delay pattern

## Testing
### Testing Standards
[Source: existing project analysis and Story 1.1]
- **Manual Testing**: Use Postman or cURL for endpoint testing
- **Test Location**: No formal test framework - manual API testing
- **Error Testing**: Test both success and failure scenarios
- **Batch Testing**: Verify rate limiting and partial failure handling

### Test Cases Required
1. **All Valid Drivers Test**: POST /api/vapi-calls/batch with `["DRV_1753320481164", "DRV_1753320481165"]`
   - Expected: 200 status, all results with `success: true` and `status: "scheduled"`
2. **Mixed Valid/Invalid Test**: POST /api/vapi-calls/batch with `["DRV_1753320481164", "INVALID_ID"]`
   - Expected: 200 status, mixed results with individual success/failure
3. **All Invalid Drivers Test**: POST /api/vapi-calls/batch with `["INVALID_1", "INVALID_2"]`
   - Expected: 200 status, all results with `success: false` and `status: "driver_not_found"`
4. **Rate Limiting Test**: Monitor timing between VAPI campaign calls (should be ~2 seconds apart)
5. **Environment Variable Test**: Test with missing VAPI credentials
   - Expected: 500 status with `configuration_error`
6. **Empty Array Test**: POST with `{"driverIds": []}`
   - Expected: 400 status with validation error

### Sample Test Commands
```bash
# Test with multiple valid drivers (based on Story 1.1 test driver)
curl -X POST http://localhost:8000/api/vapi-calls/batch \
  -H "Content-Type: application/json" \
  -d '{
    "driverIds": ["DRV_1753320481164", "DRV_1753320481165"]
  }'

# Test with mixed valid/invalid drivers
curl -X POST http://localhost:8000/api/vapi-calls/batch \
  -H "Content-Type: application/json" \
  -d '{
    "driverIds": ["DRV_1753320481164", "INVALID_DRIVER"]
  }'

# Test with empty array
curl -X POST http://localhost:8000/api/vapi-calls/batch \
  -H "Content-Type: application/json" \
  -d '{
    "driverIds": []
  }'
```

**Expected Responses:**
- Valid drivers: Status 200 with `campaignId` and `status: "scheduled"`
- Invalid drivers: Individual failure in results array with `status: "driver_not_found"`
- Empty array: Status 400 with validation error

### Developer Notes & Troubleshooting

#### Critical Implementation Details (from Story 1.1)
1. **VAPI Campaign Endpoint**: Each driver call creates a separate campaign via `/campaign` endpoint
2. **Environment Variables**: All three VAPI variables (API_KEY, ASSISTANT_ID, PHONENUMBER_ID) are mandatory
3. **Rate Limiting**: 2-second delays between calls to prevent VAPI API rate limiting
4. **Error Isolation**: Individual driver failures should not stop the batch process
5. **Sequelize Bulk Lookup**: Use `Driver.findAll({ where: { driverId: { [Op.in]: driverIds } } })`

#### Batch Processing Pattern
```javascript
// Working pattern from existing RingCentral implementation
const results = [];
for (const driver of validDrivers) {
  try {
    // Use Story 1.1 VAPI client
    const vapiResponse = await createVapiCall(driver);
    results.push({
      driverId: driver.driverId,
      success: true,
      campaignId: vapiResponse.campaignId,
      callId: vapiResponse.callId,
      phoneNumber: driver.phoneNumber,
      driverName: `${driver.firstName} ${driver.lastName}`,
      status: vapiResponse.status
    });
  } catch (error) {
    results.push({
      driverId: driver.driverId,
      success: false,
      error: error.message,
      status: 'vapi_api_error'
    });
  }
  
  // Rate limiting delay
  await new Promise(resolve => setTimeout(resolve, 2000));
}
```

#### Common Issues & Solutions
- **"assistantId should not exist" error**: Story 1.1 VAPI client not properly implemented → Verify Story 1.1 is complete
- **Database timeout on bulk lookup**: Too many driver IDs → Implement chunking for large batches
- **Rate limiting violations**: Missing delays → Ensure 2-second setTimeout between calls
- **Partial batch failures**: Need proper error isolation → Use try/catch per driver, not per batch

#### Response Status Meanings
- `scheduled`: VAPI campaign created successfully for driver
- `driver_not_found`: Driver ID doesn't exist in database
- `vapi_api_error`: VAPI API rejected individual call
- `validation_error`: Invalid request format or empty driver array

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-12-19 | 1.0 | Initial story creation for VAPI batch driver calls | Bob (Scrum Master) |
| 2024-12-19 | 2.0 | Updated with Story 1.1 learnings and working VAPI campaign structure | James (Dev Agent) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent QA review will be added here after implementation* 