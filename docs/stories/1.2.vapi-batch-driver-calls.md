# Story 1.2: VAPI Batch Driver Calls

## Status
Draft

## Story
**As a** system administrator,  
**I want** to make VAPI AI-powered calls to multiple drivers simultaneously using a list of driver IDs,  
**so that** I can efficiently conduct batch safety communications or emergency notifications to multiple drivers at once.

## Acceptance Criteria
1. Create new API endpoint `POST /api/vapi-calls/batch` that accepts an array of driver IDs
2. Process multiple drivers sequentially with rate limiting (2-second delays between calls)
3. Make VAPI API calls for each valid driver with their complete information
4. Return a comprehensive JSON response with success/failure status for each driver
5. Handle partial failures gracefully (some drivers succeed, others fail)
6. Follow existing batch processing patterns from the current RingCentral implementation
7. Implement proper error aggregation and reporting for batch operations

## Tasks / Subtasks
- [ ] Add batch VAPI call controller method (AC: 1, 2, 3, 4, 5)
  - [ ] Add `makeVapiCallsToMultipleDrivers` method to `controllers/callController.js`
  - [ ] Implement driver ID validation and bulk lookup using existing Sequelize patterns
  - [ ] Process drivers sequentially with 2-second rate limiting
  - [ ] Use existing VAPI client from Story 1.1 for individual calls
  - [ ] Aggregate results with success/failure tracking
- [ ] Create new batch API route (AC: 1)
  - [ ] Add route `POST /api/vapi-calls/batch` to `routes/calls.js`
  - [ ] Connect route to new batch controller method
- [ ] Implement batch error handling (AC: 5, 7)
  - [ ] Handle individual driver failures without stopping batch
  - [ ] Collect and report errors for each failed driver
  - [ ] Return comprehensive batch results with partial success handling
- [ ] Rate limiting implementation (AC: 2)
  - [ ] Add 2-second delays between VAPI calls to prevent API rate limiting
  - [ ] Follow existing batch processing pattern from RingCentral implementation
- [ ] Testing (AC: 1-7)
  - [ ] Test with multiple valid driver IDs
  - [ ] Test with mixed valid/invalid driver IDs
  - [ ] Test rate limiting functionality
  - [ ] Test error handling with partial failures

## Dev Notes

### Dependencies
**Requires Story 1.1 to be completed** - This story builds on the VAPI client utility and single driver call functionality from Story 1.1.

### Technology Stack Context
[Source: docs/architecture.md#technology-stack]
- **Framework**: Express.js 5.1.0 - maintain existing patterns
- **Database**: MySQL via Sequelize 6.37.7 - use existing Driver model for bulk lookups
- **HTTP Client**: Axios 1.10.0 - use existing VAPI client from Story 1.1
- **Rate Limiting**: Use JavaScript setTimeout for delays between calls

### Existing Batch Processing Pattern
[Source: existing callController.js analysis]
Follow the existing `makeCallsToMultipleDrivers` pattern:
```javascript
// Existing RingCentral batch pattern to follow
const results = [];
for (const driver of matchedDrivers) {
  try {
    // Make individual call
    results.push({ success: true, driver: driver });
  } catch (error) {
    results.push({ success: false, driver: driver, error: error.message });
  }
  // Rate limiting delay
  await new Promise(resolve => setTimeout(resolve, 2000));
}
```

### Driver Model Context
[Source: docs/architecture.md#data-models and Story 1.1]
Use existing Driver model for bulk lookups:
```javascript
// Bulk driver lookup pattern
const drivers = await Driver.findAll({
  where: {
    driverId: {
      [Op.in]: driverIds
    }
  }
});
```

### VAPI Client Integration
[Source: Story 1.1 implementation]
Reuse the VAPI client utility created in Story 1.1:
```javascript
// Import from Story 1.1
const { createVapiCall } = require('../utils/vapiClient');

// Use for each driver in batch
const vapiResponse = await createVapiCall(driver);
```

### Request/Response Format
**Request Format:**
```javascript
{
  "driverIds": ["driver_123", "driver_456", "driver_789"],
  "assistantId": "f630d5ab-148a-40f0-8059-027141d7f45f",
  "metadata": {
    "callType": "batch_safety_check",
    "source": "vapi_integration"
  }
}
```

**Response Format:**
```javascript
{
  "success": true,
  "totalDrivers": 3,
  "successfulCalls": 2,
  "failedCalls": 1,
  "results": [
    {
      "driverId": "driver_123",
      "success": true,
      "callId": "vapi_call_12345",
      "phoneNumber": "+1234567890"
    },
    {
      "driverId": "driver_456", 
      "success": true,
      "callId": "vapi_call_12346",
      "phoneNumber": "+1234567891"
    },
    {
      "driverId": "driver_789",
      "success": false,
      "error": "Driver not found"
    }
  ]
}
```

### File Locations
[Source: docs/architecture.md#project-structure and Story 1.1]
- **Controller**: `controllers/callController.js` - add new batch method
- **Routes**: `routes/calls.js` - add new batch endpoint
- **Utilities**: Use existing `utils/vapiClient.js` from Story 1.1
- **Environment**: Use existing VAPI credentials from Story 1.1

### Error Handling Strategy
Handle three types of errors:
1. **Driver Not Found**: Individual driver lookup fails
2. **VAPI API Error**: Individual VAPI call fails
3. **System Error**: Database connection or other system issues

Each error should be captured in the results array without stopping the batch process.

### Rate Limiting Requirements
[Source: existing RingCentral batch implementation]
- **Delay**: 2 seconds between individual VAPI calls
- **Method**: Use `setTimeout` with Promise wrapper
- **Pattern**: Follow existing RingCentral batch delay pattern

## Testing
### Testing Standards
[Source: existing project analysis and Story 1.1]
- **Manual Testing**: Use Postman or cURL for endpoint testing
- **Test Location**: No formal test framework - manual API testing
- **Error Testing**: Test both success and failure scenarios
- **Batch Testing**: Verify rate limiting and partial failure handling

### Test Cases Required
1. **All Valid Drivers Test**: POST /api/vapi-calls/batch with all valid driver IDs
2. **Mixed Valid/Invalid Test**: POST /api/vapi-calls/batch with some invalid driver IDs
3. **All Invalid Drivers Test**: POST /api/vapi-calls/batch with all invalid driver IDs
4. **Rate Limiting Test**: Verify 2-second delays between calls
5. **Partial Failure Test**: Test with some VAPI API failures
6. **Empty Array Test**: POST with empty driverIds array

### Sample Test Commands
```bash
# Test with multiple valid drivers
curl -X POST http://localhost:8000/api/vapi-calls/batch \
  -H "Content-Type: application/json" \
  -d '{
    "driverIds": ["driver_123", "driver_456"],
    "assistantId": "f630d5ab-148a-40f0-8059-027141d7f45f"
  }'

# Test with mixed valid/invalid drivers
curl -X POST http://localhost:8000/api/vapi-calls/batch \
  -H "Content-Type: application/json" \
  -d '{
    "driverIds": ["driver_123", "invalid_driver"],
    "assistantId": "f630d5ab-148a-40f0-8059-027141d7f45f"
  }'
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-12-19 | 1.0 | Initial story creation for VAPI batch driver calls | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent QA review will be added here after implementation* 